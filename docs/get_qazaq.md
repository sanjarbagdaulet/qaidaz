## **Задумка (черновик ТЗ / v0.2)**

### 1. Цель проекта

Оценка казахоязычности текстов Telegram (сообщений и каналов).

FastText используется как **базовый и сравнительный инструмент**, несмотря на ограниченную точность. Архитектура предусматривает добавление других методов (Lingua, правила, гибридные подходы) и массовые сравнительные эксперименты.

### 2. Платформа и подход

* Основная вычислительная нагрузка выполняется на **десктопе**.
* Сервер БД используется только для:

  * быстрой и точной выборки данных,
  * приёма результатов обработки.
* Подключение к БД осуществляется через **SSH-туннель** (без прямого открытия MariaDB наружу).

---

## **Функциональные блоки**

### 1. Основной пайплайн (обязательный)

**Назначение:** замкнутый цикл обработки данных.

**Логика работы:**

1. Выбор следующего канала, содержащего необработанные сообщения.
2. Выгрузка батча сообщений одного канала (по умолчанию 200 сообщений, `analyzed = 0`).
3. Локальный анализ текста на десктопе:

   * вычисление процента казахоязычности (`kazakh_ratio`, 0–100, int),
   * использование FastText (ветка `kk_ratio_by_f`).
4. Запись результатов обратно в БД:

   * обновление сообщений (`messages.kazakh_ratio`, `messages.analyzed = 1`) батчем,
   * пересчёт среднего значения по каналу и обновление:

     * `channels.kk_ratio_by_f`,
     * `channels.msgs_rcvd`.

**Принципы:**

* Минимальная нагрузка на сервер БД.
* Максимальная обработка и хранение промежуточных данных в памяти десктопа.
* Обработка данных батчами с транзакциями.

---

### 2. Первичный анализ (минимальный слой)

**Назначение:** быстрая проверка качества и адекватности результатов.

**Возможности:**

* Просмотр распределения `kazakh_ratio` по сообщениям.
* Сравнение среднего процента по каналам.
* Быстрая фильтрация каналов (например, по пороговым значениям).

Реализуется через SQL-запросы и локальную выборку данных.

---

### 3. Эксперименты и ручная проверка (удобство)

**Назначение:** исследовательский и отладочный слой.

**Возможности:**

* Выгрузка результатов в формат, удобный для анализа (CSV / Excel).
* Ручная проверка отдельных каналов и сообщений.
* Сравнение результатов разных методов (FastText vs другие модели).
* Гибкая фильтрация, сортировка и визуальный контроль качества.

---

## **Текущее состояние (что уже сделано)**

* Реализован основной пайплайн обработки сообщений.
* Настроено безопасное подключение к MariaDB через SSH-туннель.
* Обработка идёт батчами по одному каналу для оптимизации ресурсов.
* Результаты агрегируются на уровне каналов (`kk_ratio_by_f`).

---

## **Запланированные расширения (не в текущем этапе)**

* Резервирование сообщений (`analyzed = in-progress`) для параллельных воркеров.
* Добавление альтернативных моделей анализа.
* Автоматическое определение `not_kz` по порогам.
* Дополнительные агрегаты и метрики.

---




























Вот **чёткое, актуальное ТЗ + документация** для текущей схемы сервер–десктоп с использованием SQLite и fastText. Сделано так, чтобы полностью отражать текущую архитектуру и процессы.

---

# Техническое задание (ТЗ)

**Проект:** Анализ казахоязычности Telegram-постов (сервер-десктоп)
**Платформа:** Python + SQLite + Flask + fastText
**Цель:** Синхронизировать сообщения между сервером и десктопом, вычислить процент казахских слов, сохранить результаты в серверной БД.

**Ограничения VPS:** 1 CPU, 1 ГБ RAM, 10 ГБ SSD — сервер должен быть минимально нагружен.
**Интервал обработки:** однократный запуск скрипта (pull-batch), без постоянного цикла.
**Безопасность:** доступ только по токену `X-Auth-Token`.

---

## 1. Архитектура

**Desktop:**

* Получает новые сообщения с сервера (`GET /pending_messages`)
* Сохраняет их в локальную БД (`telegram_channels.db`)
* Вычисляет `kazakh_ratio` с использованием fastText (`lid.176.bin`)
* Обновляет локально поле `analyzed = 1`
* Считает среднее `kk_ratio_by_l` по каждому каналу
* Отправляет обратно на сервер:

  * обновлённые сообщения (`POST /upload_messages`)
  * обновлённые каналы (`POST /upload_channels`)

**Server:**

* Поддерживает «истину» по сообщениям и каналам
* Отдаёт только **непроанализированные сообщения**
* Применяет обновления от десктопа
* Не выполняет анализ текста

---

## 2. Структура базы данных

### 2.1 Таблица `channels`

```sql
CREATE TABLE channels (
    channel_id INTEGER PRIMARY KEY,
    title TEXT NOT NULL,
    date INTEGER,
    access_hash INTEGER NOT NULL,
    username TEXT,
    participants_count INTEGER NOT NULL,
    linked_monoforum_id INTEGER,
    repeats_count INTEGER,
    not_kz INTEGER,
    kk_ratio_by_l REAL,
    kk_ratio_by_f REAL,
    c_rcvd INTEGER NOT NULL DEFAULT 0,
    msgs_rcvd INTEGER NOT NULL DEFAULT 0
);
```

### 2.2 Таблица `messages`

```sql
CREATE TABLE messages (
    id INTEGER NOT NULL,
    channel_id INTEGER NOT NULL,
    date INTEGER NOT NULL,
    message TEXT,
    media_type TEXT NOT NULL,
    kazakh_ratio INTEGER NOT NULL DEFAULT 0,
    analyzed INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY (id, channel_id)
);
```

---

## 3. API сервера (Flask)

### 3.1 `GET /pending_messages`

* Загружает **непроанализированные сообщения** (`analyzed = 0`)
* Параметры: лимит `BATCH_LIMIT = 500`
* Заголовки: `X-Auth-Token`
* Ответ JSON:

```json
[
  { "id": 123, "channel_id": 10, "text": "Сообщение" },
  ...
]
```

---

### 3.2 `POST /upload_messages`

* Принимает результаты анализа сообщений от десктопа
* Заголовки: `X-Auth-Token`
* JSON:

```json
[
  { "id": 123, "channel_id": 10, "kazakh_ratio": 72 },
  ...
]
```

* Сервер обновляет:

  * `messages.kazakh_ratio`
  * `messages.analyzed = 1`

* Ответ JSON: `{"updated": N}`

---

### 3.3 `POST /upload_channels`

* Принимает среднее `kk_ratio_by_l` по каналам от десктопа
* Заголовки: `X-Auth-Token`
* JSON:

```json
[
  { "channel_id": 10, "kk_ratio_by_l": 41.3 },
  ...
]
```

* Сервер обновляет:

  * `channels.kk_ratio_by_l`

* Ответ JSON: `{"updated": N}`

---

## 4. Desktop скрипт (`get.py`)

* **Подключение:** локальная БД + fastText
* **Функции:**

  1. `get_pending_messages()` — получить новые сообщения
  2. `predict_kazakh_ratio(text)` — вычислить % казахских слов
  3. `save_messages_locally(messages)` — обновить локально
  4. `calc_channel_averages()` — вычислить среднее по каналам
  5. `upload_messages(results)` — отправить сообщения на сервер
  6. `upload_channels(results)` — отправить каналы на сервер
* **Поведение:** один запуск = один батч

---

## 5. Логика ETL

1. Desktop запрашивает `BATCH_LIMIT` сообщений с сервера
2. Анализирует тексты и сохраняет локально (`analyzed = 1`)
3. Вычисляет среднее `kk_ratio_by_l` по каналам
4. Отправляет результаты сообщений и каналов на сервер
5. Сервер применяет обновления
6. Сервер больше не отдаёт эти сообщения

---

## 6. Безопасность

* Все эндпоинты проверяют `X-Auth-Token`
* Сервер не логирует подключений клиентов
* Flask работает в режиме `debug=False`, для продакшена можно заменить на WSGI

---

## 7. Преимущества схемы

* Сервер минимально нагружен
* Desktop полностью управляет анализом
* Нет повторной обработки
* Можно безопасно запускать несколько раз
* Подходит для VPS с 1 CPU, 1 GB RAM

---

Если хочешь, я могу сразу нарисовать **схему работы сервер-десктоп** в виде простого блок-схема/диаграммы для документации — будет удобно показывать.

Хочешь, чтобы я это сделал?
