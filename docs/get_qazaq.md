Ниже — **развёрнутое резюме всего диалога**, без добавления новых идей, только фиксация того, к чему ты пришёл и как это должно работать концептуально.

---

## 1. Базовая цель системы

Ты строишь систему **расширения графа Telegram-каналов** и их **ручной классификации** по принадлежности к Казахстану, при этом:

* ты **не хочешь полагаться на автоматику** для финальных решений;
* автоматика нужна **только для сбора данных и приоритизации**;
* финальное решение (`not_kz=1` или `not_kz=2`) всегда принимает человек.

Главный риск, который ты постоянно учитываешь, — **утечка**:
когда в расширение начинают попадать не-KZ кластеры и дальше сами себя размножают.

---

## 2. Статусы `not_kz` и их смысл

Фактически используется такая модель:

* `not_kz = 1` — **жёстко не KZ**, граница, блок
* `not_kz = 2` — **разрешённый / KZ-контекст**, центр системы
* `not_kz = 4` — **карантин**, канал сомнительный, требует ручного решения
* `not_kz = 3` — **legacy-метка**, историческая, вынесена в отдельную таблицу и используется только для сортировки ручной очереди
* `not_kz = 0` — не классифицирован (рабочее промежуточное состояние)

Важно:

* автоматического перевода `0 → 1/2` **нет**;
* все признаки используются **не для решения**, а для **очереди и сортировки**.

---

## 3. Архитектура скриптов (один скрипт — одна задача)

Ты чётко развёл ответственность:

### `get_messages`

* охват **100% каналов** из `channels`;
* никаких фильтров по `not_kz`;
* только приоритеты (крупные, давно не обновлялись и т.п.);
* задача — **собрать сообщения**.

### `get_qazaq`

* анализирует **все собранные сообщения**;
* считает языковые метрики (`kk_ratio_by_f` и другие);
* сохраняет агрегаты в `channels`;
* **не принимает решений**, только считает признаки.

### `get_channels`

* отвечает **только за расширение графа similar**;
* работает по строго ограниченной схеме волн;
* не занимается языками, не классифицирует.

---

## 4. Similar vs Recommended

Ты зафиксировал корректную терминологию:

* в Telegram это **`similar channels`**, а не `recommended`;
* в логике и документации используется термин **similar**;
* таблица связей (`recs`) по смыслу — граф `seed → similar`.

---

## 5. Центр (CORE) и расширение

### Центр (CORE)

Канал считается центром, если:

* `not_kz = 2`
* `kk_ratio_by_f > 20`

**Только такие каналы имеют право инициировать расширение.**

---

### Расширение: ограниченная глубина 2

Ты уточнил ключевой момент:
глубина **формально 2**, но **логически ограниченная**.

Пример:

```
CORE: qazaqstantv

1-я волна (R1):
  ztb
  tengrinews
  kozachkow

2-я волна (R2):
  ztb → orda, almatv
  tengrinews → astanovka, glego
  kozachkow → egovpress, neftegaz
```

Правила:

* по CORE → делаем similar (волна 1)
* по R1 → делаем similar (волна 2)
* по R2 → **никогда** не делаем similar
* дальше расширение **запрещено**

Это ключевая защита от утечек.

---

## 6. Как определяется «волна»

Ты рассматривал варианты и пришёл к двум допустимым архитектурам:

### Вариант 1 (чище)

Отдельная таблица `similar_seeds`:

* хранит `(channel_id, depth, processed)`
* depth = 1 → CORE
* depth = 2 → R1

### Вариант 2 (проще)

Добавить `depth` прямо в таблицу `recs`:

* `recs.depth = 1` → связь получена от CORE
* `recs.depth = 2` → связь получена от R1
* по наличию/отсутствию `recs` можно понять:

  * был ли канал seed’ом
  * на какой волне

Ты понял ограничения этого варианта (очередь неявная), но он **допустим**.

---

## 7. Признаки, которые ты используешь (важно: не для автоматики)

Ты чётко сказал:
**признаки ≠ решение**, признаки = **сортировка очереди**.

### Основные признаки

1. **Язык**
   Самый сильный сигнал:

   * высокий `kk_ratio_by_f` — в сторону KZ

2. **Похожие каналы**

   * доля казахоязычных / KZ-каналов в similar
   * отражает принадлежность к кластеру

3. **TGStat**

   * сначала проверка по твоему **локальному списку KZ-каналов**;
   * если нет — `GET tgstat.ru/@username`;
   * редирект на `kaz.tgstat.com` ⇒ сильный KZ-признак;
   * ты осознанно используешь результаты работы админов каналов, но **без слепой веры**.

4. **Описание канала**

   * упоминание регистрации в **РКН** ⇒ сильный признак РФ;
   * прочие маркеры — вспомогательные.

5. **Entities сообщений**

   * Telegram возвращает список entities;
   * наличие телефонных номеров;
   * по номеру можно косвенно определить страну оператора;
   * **слабый, но полезный сигнал**.

---

## 8. Ключевое архитектурное решение

Ты чётко сформулировал принцип:

> **Автоматика никогда не будет стопроцентно верной.
> Поэтому автоматических решений не делаем вообще.**

Следовательно:

* нет `0 → 1` или `0 → 2` автоматически;
* нет «магических порогов»;
* система:

  1. собирает признаки,
  2. считает суммарный скор,
  3. сортирует каналы,
  4. отдаёт их тебе на ручной разбор.

---

## 9. Ручная модерация

* основной объект ручной работы — `not_kz = 4` (карантин);
* каналы с legacy-seeing (`not_kz=3` в отдельной таблице) **опускаются вниз очереди**;
* ты смотришь каналы **в порядке убывания уверенности признаков**, а не вслепую.

---

## 10. Итоговая философия системы

Если обобщить в одной фразе:

> **Система не решает — она подготавливает контекст.
> Решает человек.**

Ты строишь не классификатор, а:

* управляемый граф расширения,
* с жёсткими границами,
* с богатым контекстом признаков,
* и с удобной очередью ручного принятия решений.

Если захочешь, в следующем шаге мы можем:

* превратить это резюме в **чистовой документ / README**,
* или описать **структуру скоринга** (какие признаки + веса, без автоматических решений).
