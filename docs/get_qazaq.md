Ок. Ниже — **обновлённое, целостное ТЗ / резюме диалога**, с учётом всего последнего и **без проектирования наперёд**. Это именно фиксация договорённостей.

---

# ТЗ (черновик)

## Система ручного выявления казахстанских Telegram-каналов

*(с автоматическим сбором признаков и управляемым расширением)*

---

## 1. Цель системы

Создать систему, в которой:

* **человек** принимает финальное решение, является ли канал казахстанским;
* **автоматика**:

  * расширяет граф каналов (через `similar`),
  * собирает данные и признаки,
  * сортирует каналы по вероятности;
* **нет автоматической классификации** `not_kz=1/2`;
* система помогает **быстро находить наиболее вероятные KZ-каналы**, особенно среди похожих.

---

## 2. Базовые статусы каналов

Используемые значения `not_kz`:

* `1` — точно не казахстанский (жёсткий блок)
* `2` — подтверждён как казахстанский (ручное решение)
* `4` — карантин (сомнительный, требует ручного решения)
* `0` — не рассмотрен

`not_kz=3` — legacy-метка, вынесена в отдельную таблицу и используется **только для сортировки** при ручном разборе.

⚠️ Автоматика **никогда** не переводит канал в `1` или `2`.

---

## 3. Общая логика работы (как ты видишь систему)

1. Ты вручную находишь канал и понимаешь, что он казахстанский
   (язык, события, контекст, география).
2. Ставишь `not_kz = 2` (пример: канал **«Шымсити»**).
3. Система:

   * получает **похожие каналы** (similar),
   * собирает по ним данные,
   * формирует очередь на ручной просмотр, **отсортированную по признакам**.
4. Ты просматриваешь каналы **не все подряд**, а начиная с наиболее вероятных KZ.
5. Подтверждённые тобой каналы (`not_kz=2`) могут становиться новыми “якорями” расширения.
6. Процесс продолжается, пока:

   * не исчерпается казахоязычный кластер,
   * затем — русскоязычные KZ через дополнительные признаки.

---

## 4. Расширение графа каналов (get_channels)

### Источник расширения

* Только каналы с `not_kz = 2`.

### Механика

* Используется Telegram-функция **`similar channels`**.
* Расширение ограничено:

  * первая волна — похожие от `not_kz=2`,
  * вторая волна — похожие от каналов первой волны,
  * дальше расширение **запрещено**.

Цель:
избежать утечек и неконтролируемого роста графа.

---

## 5. Признаки (используются ТОЛЬКО для сортировки)

### 5.1 Язык сообщений (самый сильный признак)

* Берутся последние ~100 сообщений канала.
* Анализ через fastText.
* Считаются **все языки**, а не только казахский.
* Учитываются ограничения:

  * мало текстовых сообщений,
  * каракалпакские каналы,
  * русскоязычные KZ,
  * “салам” как нерелевантный маркер.

### 5.2 Похожие каналы

* Доля каналов, уже подтверждённых как KZ (`not_kz=2`).
* Используется осторожно, так как:

  * много каналов имеют статус `0`,
  * статистика может искажаться.

### 5.3 TGStat

* Внешний источник, **не связанный напрямую с Telegram**.
* Использование:

  1. Проверка по **локальному списку KZ-каналов**, собранному вручную.
  2. Если нет — `GET` запрос по username на `tgstat.ru`.
  3. Редирект на `kaz.tgstat.com` → **сильный, но не абсолютный признак KZ**.
* Ограничения:

  * возможны ложные KZ (персидские и т.п. каналы),
  * многие KZ-админы не добавляют каналы в TGStat.
* Плюсы:

  * можно находить каналы, которых нет в “similar”,
  * в т.ч. закрытые каналы.

### 5.4 Описание канала

* Если в описании есть:

  * ссылка или упоминание регистрации в **РКН**
    → сильный признак РФ.
* Используется как фильтр/маркер, не как автоматическое решение.

### 5.5 Entities сообщений

Используются entities, которые Telegram возвращает вместе с сообщениями:

* `MessageEntityTextUrl`
* `MessageEntityUrl`
* `MessageEntityPhone`

Косвенные признаки:

* домены `.kz`,
* номера телефонов (по стране/оператору),
* локальные сайты.

Слабый сигнал, используется только в сумме с другими.

---

## 6. Скрипты и их ответственность

*(один скрипт — одна задача)*

### 6.1 `get_messages`

* Получает последние сообщения **для всех каналов** из `channels`.
* Без фильтрации по `not_kz`.
* Заполняет:

  * таблицу `messages`,
  * таблицу `message_entities`.

---

### 6.2 `get_languages` *(бывший get_qazaq, переименовать)*

* Анализирует тексты сообщений.
* Определяет **все языки**.
* Сохраняет агрегаты по каналам (доли, количество текстовых сообщений).
* Не принимает решений.

---

### 6.3 `get_channels`

* Получает **similar channels**.
* Источник: только `not_kz=2`.
* Заполняет:

  * таблицу каналов (`channels`, если новый),
  * таблицу связей similar (`recs` / `similar_edges`).
* Расширение ограничено двумя волнами.

---

### 6.4 `get_tgstat`

* Работает с TGStat:

  * проверка по локальному списку,
  * HTTP-запрос с проверкой редиректа.
* Записывает результат как признак (не решение).

---

### 6.5 `get_channel_descriptions`

* Получает и обновляет описания каналов.
* Извлекает маркеры (РКН и т.п.).

---

### 6.6 `confirm_channel`

* Принимает **ручное решение от пользователя**:

  * `not_kz = 2`
  * `not_kz = 1`
* Единственный скрипт, который меняет итоговый статус.

---

### 6.7 `main / orchestrator`

* Главный управляющий скрипт.
* Следит за:

  * очередями,
  * прогрессом,
  * запуском остальных скриптов.
* Не содержит бизнес-логики классификации.

---

## 7. Ключевые принципы системы

* ❌ нет автоклассификации;
* ✅ автоматика = сбор + сортировка;
* ✅ человек = решение;
* ❌ бесконечное расширение запрещено;
* ✅ система масштабируется за счёт **умной очереди**, а не ML.

---

Если скажешь, следующим шагом можем:

* оформить это в **структурированное README / Markdown**,
* или отдельно зафиксировать **схему таблиц**,
* или описать **как выглядит экран/CLI ручной модерации**.
